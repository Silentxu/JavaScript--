# 对象方法
### call()和apply() 
这两个方法都是函数对象的方法，需要通过函数对象来调用
党对函数调用call()和apply()都会调用函数执行
在调用call和apply()可以将一个对俩指定为第一个参数
    此时这个对象将会成为函数执行时的this
```js
function fun(){
    alert("我是函数对象！");
}
fun.call();
fun.apply();
fun();
```
```js
var obj = {
    name : "obj",
    sayName:function(){
        alert(this,name);
    }
};

var obj2 = {
    name:"obj2"
};
obj.sayName.apply(obj2);//obj2
```
>call()方法可以将实参在对象之后依次传递
apply()方法需要将实参封装到一个数组中统一传递
```js
function fun(a,b){
    console.log("a =" + a);
    console.log("b =" + b);
}
var obj = {
    name : "obj",
    sayName:function(){
        alert(this,name);
    }
};

fun.call(obj,1,2);//a = 1 b =2
fun.apply(obj,1,2);//报错
fun.apply(obj,[1,2]);//a = 1  b=2

var obj2 = {
    name:"obj2"
};
```
this的情况：
1. 以函数形式调用时，this是window
2. 以方法形式调用时，this是方法的对象
3. 以构造函数的形式调用时，this是新创建的那个对象
4. 使用call和apply调用时，this是指定的那个对象

### arguments 
在调用函数时，浏览器每次都会传递进两个隐含的参数
1. 函数的上下文对象this
2. 封装实参对象arguments
   1. arguments是一个**类数组对象**（不是数组），他也可以通过索引来操作数据，也可以获取长度
   2. 在调用函数时，我们所传递的实参都会在arguments中保存
   3. arguments.length可用来获取实参的长度
   4. 我们即使不定义形参，也可以通过arguments来使用实参
      1. 只不过比较麻烦
      2. arguments[0]表示第一个实参
      3. arguments[1]表示第二个实参
   5. 它里面有一个属性叫做callee
      1. 这个属性对应一个函数对象，就是当前正在执行的函数的对象
```js 
   function fun(){
       console.log(arguments instanceof Array);//false
       console.log(Array.isArray(arguments));//false
       console.log(arguments.length);//2
       console.log(arguments[0]);//"hello"
       console.log(arguments.callee);
   }
   fun("hello",true);
```
### Date对象
